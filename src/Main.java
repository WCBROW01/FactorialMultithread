import java.math.BigInteger;
import java.util.InputMismatchException;
import java.util.Scanner;

/**
 * This program generates a factorial with parallel processing!
 * @author Will Brown
 * @version 1.0
 */

public class Main {
	
	// This is global because it is shared with createResult.
	private static BigInteger result;
	
	/**
	 * Main method. Mostly for entering parameters and displaying text.
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int number, threadCount;
		char again = 'y';
		
		while (again == 'y' || again == 'Y') {
			try {
				System.out.print("How many threads do you want to use? (0 to automatically allocate): ");
				threadCount = input.nextInt();
				
				// Clear anything left in the buffer
				input.nextLine();
				
				System.out.print("Enter number to complete factorial: ");
				number = input.nextInt();
				
				System.out.println("Factorial of " + number + " is " + factorial(threadCount, number));
			
			} catch (InputMismatchException e) {
				System.out.println("Invalid number!");
				
				// Clear anything left in the buffer
				input.nextLine();
			} catch (InterruptedException e) {
				System.out.println("Something was interrupted. This shouldn't happen.");
				e.printStackTrace();
			}
			
			System.out.print("Want to continue? (y/n): ");
			again = input.next().strip().charAt(0);
		}
		
		input.close();
	}
	
	/**
	 * Sets up the threads and returns the result once everything is done.
	 * @param threadCount total number of threads
	 * @param number input to calculate the factorial of
	 * @return The resulting factorial.
	 * @throws InterruptedException
	 */
	private static BigInteger factorial(int threadCount, int number) throws InterruptedException {
		int threadNum;
		result = BigInteger.ONE;

		// If the input is less than 1 (either 0 or a negative number), grab the number of available processors and use that.
		threadCount = threadCount < 1 ? Runtime.getRuntime().availableProcessors() : threadCount;
		
		// If we have a greater quantity of threads than numbers to multiply, fall back to 1 thread.
		threadCount = number < threadCount ? 1 : threadCount;
		
		// Create an array the size of the thread count.
		FactThread[] factThread = new FactThread[threadCount];
		
		// Start each thread.
		for (threadNum = 0; threadNum < threadCount; threadNum++) {
			factThread[threadNum] = new FactThread(threadNum, threadCount, number);
			factThread[threadNum].start();
		}
		
		/*
		 *  Stalls the program, but using the sleep method allows for any thread to call createResult on demand.
		 *  It will basically keep the program from returning the result until every thread is finished.
		 *  I was previously just using the join method for each thread and multiplying the results sequentially,
		 *  but that added a ton of overhead because there was a lot more waiting around.
		 *  This allows for each thread to just send it's result once it finishes because the order doesn't actually matter and
		 *  as a result, leaves a lot less downtime for the CPU. 
		 */
		while(Thread.activeCount() > 1) {
			Thread.sleep(0);
		}
		
		return result;
	}
	
	/**
	 * Synchronized method that joins the result of each thread into the full factorial.
	 * @param section an individual section of the factorial, generated by a thread.
	 */
	public static synchronized void createResult(BigInteger section) {
		result = result.multiply(section);
	}
}
